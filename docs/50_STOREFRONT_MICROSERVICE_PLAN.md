
# üè™ Plano de Implementa√ß√£o: Storefront Microservice

**Data de Cria√ß√£o**: 15 de Outubro de 2025  
**Status**: ‚úÖ Conclu√≠do (100%)  
**Objetivo**: Criar o segundo microsservi√ßo da arquitetura conforme desafio original

---

## üéØ Objetivo do Desafio

> **Construir dois microsservi√ßos principais:**
> - ‚úÖ **Warehouse (Armaz√©m)** - Gerencia estoque e opera√ß√µes de armaz√©m
> - ‚ùå **Storefront (Vitrine/Loja)** - Interface de venda para clientes
>
> **Comunica√ß√£o:**
> - üîÑ **S√≠ncrona** - HTTP/REST entre servi√ßos
> - üì® **Ass√≠ncrona** - RabbitMQ para eventos

---

## üìã Situa√ß√£o Atual

### ‚úÖ Warehouse Microservice (COMPLETO)
```
warehouse-franklindex.doo/
‚îú‚îÄ‚îÄ src/main/java/br/com/dio/warehouse/
‚îÇ   ‚îú‚îÄ‚îÄ domain/              ‚úÖ Completo
‚îÇ   ‚îú‚îÄ‚îÄ application/         ‚úÖ Completo
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/      ‚úÖ Completo
‚îÇ   ‚îî‚îÄ‚îÄ adapter/             ‚úÖ Completo
‚îú‚îÄ‚îÄ docker-compose.yml       ‚úÖ PostgreSQL + RabbitMQ
‚îî‚îÄ‚îÄ API REST                 ‚úÖ 14 endpoints funcionando
```

**Portas:**
- Aplica√ß√£o: `8080`
- PostgreSQL: `5432`
- RabbitMQ: `5672` (AMQP) e `15672` (Management)

### ‚úÖ Storefront Microservice (COMPLETO)

**Status:** 100% conclu√≠do. Todas as funcionalidades planejadas para o Storefront/frontend foram implementadas e testadas com sucesso.

---

## üèóÔ∏è Arquitetura Proposta

### Vis√£o Geral do Ecossistema

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    CLIENTE (Frontend)                        ‚îÇ
‚îÇ                    Angular/React/Vue                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ HTTP/REST
                 ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              üè™ STOREFRONT MICROSERVICE                     ‚îÇ
‚îÇ                    (Porta 8081)                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Domain:                                                    ‚îÇ
‚îÇ  - Product (Produto)                                        ‚îÇ
‚îÇ  - ShoppingCart (Carrinho)                                  ‚îÇ
‚îÇ  - Order (Pedido)                                           ‚îÇ
‚îÇ  - Customer (Cliente)                                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Funcionalidades:                                           ‚îÇ
‚îÇ  ‚úì Cat√°logo de produtos                                    ‚îÇ
‚îÇ  ‚úì Carrinho de compras                                     ‚îÇ
‚îÇ  ‚úì Checkout e pedidos                                      ‚îÇ
‚îÇ  ‚úì Consulta disponibilidade (chama Warehouse via HTTP)     ‚îÇ
‚îÇ  ‚úì Consome eventos de estoque (RabbitMQ)                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ                    ‚îÇ
             ‚îÇ HTTP/REST          ‚îÇ RabbitMQ Events
             ‚îÇ (S√≠ncrono)         ‚îÇ (Ass√≠ncrono)
             ‚ñº                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              üè≠ WAREHOUSE MICROSERVICE                      ‚îÇ
‚îÇ                    (Porta 8080)                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Domain:                                                    ‚îÇ
‚îÇ  - DeliveryBox (Entrega)                                    ‚îÇ
‚îÇ  - BasicBasket (Cesta B√°sica)                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Funcionalidades:                                           ‚îÇ
‚îÇ  ‚úì Gerenciamento de estoque                                ‚îÇ
‚îÇ  ‚úì Recebimento de entregas                                 ‚îÇ
‚îÇ  ‚úì Venda de cestas                                         ‚îÇ
‚îÇ  ‚úì Descarte de vencidos                                    ‚îÇ
‚îÇ  ‚úì Publica eventos (DeliveryReceived, BasketsSold)         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   üíæ INFRAESTRUTURA                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - PostgreSQL (2 databases)                                 ‚îÇ
‚îÇ    ‚Ä¢ warehouse_db (porta 5432)                             ‚îÇ
‚îÇ    ‚Ä¢ storefront_db (porta 5433)                            ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  - RabbitMQ (compartilhado)                                ‚îÇ
‚îÇ    ‚Ä¢ AMQP: 5672                                            ‚îÇ
‚îÇ    ‚Ä¢ Management: 15672                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üì¶ Storefront - Modelo de Dom√≠nio

### Agregados e Entidades

#### 1. **Product (Produto)**
```java
@Entity
@Getter
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Product {
    @Id
    private UUID id;
    
    private String name;
    private String description;
    private Money price;  // Pre√ßo consultado do Warehouse
    private Integer availableQuantity;  // Cache do estoque
    private String imageUrl;
    private ProductCategory category;
    private boolean active;
    
    @Embedded
    private Timestamps timestamps;
    
    // M√©todos de dom√≠nio
    public boolean isAvailable() {
        return active && availableQuantity > 0;
    }
    
    public void updateStock(int quantity) {
        this.availableQuantity = quantity;
    }
}

enum ProductCategory {
    BASIC_BASKET,
    PREMIUM_BASKET,
    ORGANIC_BASKET
}
```

#### 2. **ShoppingCart (Carrinho)**
```java
@Entity
@Getter
@Builder
public class ShoppingCart {
    @Id
    private UUID id;
    
    @ManyToOne
    private Customer customer;
    
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    private List<CartItem> items = new ArrayList<>();
    
    private CartStatus status;
    
    @Embedded
    private Timestamps timestamps;
    
    // M√©todos de dom√≠nio
    public void addItem(Product product, int quantity) {
        // Valida disponibilidade
        // Adiciona ou atualiza item
    }
    
    public void removeItem(UUID productId) {}
    
    public Money calculateTotal() {
        return items.stream()
            .map(item -> item.getSubtotal())
            .reduce(Money.ZERO, Money::add);
    }
    
    public int getTotalItems() {
        return items.stream()
            .mapToInt(CartItem::getQuantity)
            .sum();
    }
}

@Embeddable
@Getter
class CartItem {
    @ManyToOne
    private Product product;
    
    private Integer quantity;
    
    private Money unitPrice;
    
    public Money getSubtotal() {
        return unitPrice.multiply(quantity);
    }
}

enum CartStatus {
    ACTIVE,
    CONVERTED_TO_ORDER,
    ABANDONED
}
```

#### 3. **Order (Pedido)**
```java
@Entity
@Table(name = "orders")
@Getter
@Builder
public class Order {
    @Id
    private UUID id;
    
    private String orderNumber;  // AUTO-GENERATED (ex: ORD-20251015-0001)
    
    @ManyToOne
    private Customer customer;
    
    @OneToMany(cascade = CascadeType.ALL)
    private List<OrderItem> items;
    
    private Money subtotal;
    private Money tax;
    private Money total;
    
    private OrderStatus status;
    
    @Embedded
    private ShippingAddress shippingAddress;
    
    @Embedded
    private PaymentInfo paymentInfo;
    
    @Embedded
    private Timestamps timestamps;
    
    @Version
    private Long version;
    
    // M√©todos de dom√≠nio
    public void confirm() {
        if (status != OrderStatus.PENDING) {
            throw new InvalidOrderStateException("Order already confirmed");
        }
        this.status = OrderStatus.CONFIRMED;
    }
    
    public void cancel() {
        if (status == OrderStatus.DELIVERED) {
            throw new InvalidOrderStateException("Cannot cancel delivered order");
        }
        this.status = OrderStatus.CANCELLED;
    }
}

@Embeddable
@Getter
class OrderItem {
    @ManyToOne
    private Product product;
    
    private Integer quantity;
    private Money unitPrice;
    private Money subtotal;
}

enum OrderStatus {
    PENDING,           // Criado mas n√£o confirmado
    CONFIRMED,         // Confirmado, aguardando separa√ß√£o
    PROCESSING,        // Warehouse est√° separando
    SHIPPED,           // Enviado
    DELIVERED,         // Entregue
    CANCELLED          // Cancelado
}
```

#### 4. **Customer (Cliente)**
```java
@Entity
@Getter
@Builder
public class Customer {
    @Id
    private UUID id;
    
    private String email;
    private String fullName;
    private String cpf;
    private String phone;
    
    @Embedded
    private Address defaultAddress;
    
    private CustomerType type;
    
    @Embedded
    private Timestamps timestamps;
}

enum CustomerType {
    INDIVIDUAL,   // Pessoa f√≠sica
    BUSINESS      // Pessoa jur√≠dica
}
```

---

## üîÑ Comunica√ß√£o entre Microsservi√ßos

### 1. **Comunica√ß√£o S√≠ncrona (HTTP/REST)**

**Storefront ‚Üí Warehouse**

```java
// Storefront consulta disponibilidade em tempo real
@Service
@RequiredArgsConstructor
public class WarehouseClient {
    
    private final RestTemplate restTemplate;
    
    @Value("${warehouse.api.url}")
    private String warehouseUrl;  // http://localhost:8080
    
    public StockInfoResponse checkStock() {
        String url = warehouseUrl + "/api/v1/stock";
        return restTemplate.getForObject(url, StockInfoResponse.class);
    }
    
    public boolean reserveBaskets(int quantity) {
        String url = warehouseUrl + "/api/v1/baskets/reserve";
        ReserveRequest request = new ReserveRequest(quantity);
        
        try {
            restTemplate.postForObject(url, request, ReserveResponse.class);
            return true;
        } catch (HttpClientErrorException e) {
            return false;
        }
    }
}
```

### 2. **Comunica√ß√£o Ass√≠ncrona (RabbitMQ)**

**Warehouse ‚Üí Storefront** (Eventos)

```java
// Storefront consome eventos do Warehouse
@Component
@RabbitListener(queues = "storefront.stock.updates")
@RequiredArgsConstructor
public class StockUpdateEventConsumer {
    
    private final ProductService productService;
    
    @RabbitHandler
    public void handleBasketsSoldEvent(BasketsSoldEvent event) {
        log.info("Received BasketsSoldEvent: {} baskets sold", event.quantity());
        
        // Atualiza cache de estoque local
        productService.decreaseStock(event.quantity());
    }
    
    @RabbitHandler
    public void handleDeliveryReceivedEvent(DeliveryReceivedEvent event) {
        log.info("Received DeliveryReceivedEvent: {} baskets", event.totalQuantity());
        
        // Atualiza disponibilidade de produtos
        productService.increaseStock(event.totalQuantity().intValue());
    }
}

// Storefront publica eventos de pedidos
@Component
@RequiredArgsConstructor
public class OrderEventPublisher {
    
    private final RabbitTemplate rabbitTemplate;
    
    public void publishOrderCreated(Order order) {
        OrderCreatedEvent event = OrderCreatedEvent.builder()
            .eventId(UUID.randomUUID())
            .occurredOn(Instant.now())
            .orderId(order.getId())
            .customerId(order.getCustomer().getId())
            .totalItems(order.getItems().size())
            .totalAmount(order.getTotal().getAmount())
            .build();
        
        rabbitTemplate.convertAndSend(
            "storefront.events",
            "order.created",
            event
        );
    }
}
```

**Configura√ß√£o RabbitMQ**

```yaml
# storefront/application.yml
spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: ${RABBITMQ_USER}
    password: ${RABBITMQ_PASSWORD}
    listener:
      simple:
        retry:
          enabled: true
          initial-interval: 3s
          max-attempts: 3
          multiplier: 2.0

# Exchanges e Queues
rabbitmq:
  exchanges:
    warehouse-events: warehouse.events
    storefront-events: storefront.events
  queues:
    stock-updates: storefront.stock.updates
    order-notifications: warehouse.order.notifications
  routing-keys:
    baskets-sold: baskets.sold
    delivery-received: delivery.received
    order-created: order.created
```

---

## üì° API REST do Storefront

### Endpoints Principais

#### **Products (Cat√°logo)**
```
GET    /api/v1/products                 - Listar produtos (paginado)
GET    /api/v1/products/{id}            - Detalhe do produto
GET    /api/v1/products/search          - Buscar por nome/categoria
GET    /api/v1/products/available       - Produtos dispon√≠veis em estoque
```

#### **Shopping Cart**
```
GET    /api/v1/cart                     - Obter carrinho atual
POST   /api/v1/cart/items               - Adicionar item ao carrinho
PUT    /api/v1/cart/items/{productId}   - Atualizar quantidade
DELETE /api/v1/cart/items/{productId}   - Remover item
DELETE /api/v1/cart                     - Limpar carrinho
POST   /api/v1/cart/checkout            - Finalizar compra (cria pedido)
```

#### **Orders**
```
GET    /api/v1/orders                   - Listar pedidos do cliente
GET    /api/v1/orders/{id}              - Detalhe do pedido
POST   /api/v1/orders                   - Criar pedido (via checkout)
PUT    /api/v1/orders/{id}/cancel       - Cancelar pedido
GET    /api/v1/orders/{id}/status       - Status do pedido
```

#### **Customers**
```
POST   /api/v1/customers                - Cadastrar cliente
GET    /api/v1/customers/me             - Dados do cliente logado
PUT    /api/v1/customers/me             - Atualizar dados
PUT    /api/v1/customers/me/address     - Atualizar endere√ßo
```

#### **Authentication**
```
POST   /api/v1/auth/register            - Registrar novo cliente
POST   /api/v1/auth/login               - Login
POST   /api/v1/auth/logout              - Logout
GET    /api/v1/auth/me                  - Usu√°rio atual
```

---

## üõ†Ô∏è Tecnologias (Storefront)

### Stack Id√™ntico ao Warehouse

```kotlin
// build.gradle.kts
dependencies {
    // Spring Boot
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-security")
    implementation("org.springframework.boot:spring-boot-starter-amqp")
    implementation("org.springframework.boot:spring-boot-starter-actuator")
    
    // Spring Cloud
    implementation("org.springframework.cloud:spring-cloud-starter-openfeign")
    implementation("org.springframework.cloud:spring-cloud-starter-circuitbreaker-resilience4j")
    
    // Database
    implementation("org.postgresql:postgresql")
    implementation("org.flywaydb:flyway-core")
    
    // OpenAPI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.4")
    
    // JWT
    implementation("io.jsonwebtoken:jjwt-api:0.12.6")
    runtimeOnly("io.jsonwebtoken:jjwt-impl:0.12.6")
    runtimeOnly("io.jsonwebtoken:jjwt-jackson:0.12.6")
    
    // Lombok
    compileOnly("org.projectlombok:lombok")
    annotationProcessor("org.projectlombok:lombok")
    
    // MapStruct
    implementation("org.mapstruct:mapstruct:1.6.3")
    annotationProcessor("org.mapstruct:mapstruct-processor:1.6.3")
    
    // Testing
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.springframework.security:spring-security-test")
    testImplementation("org.testcontainers:postgresql")
    testImplementation("org.testcontainers:rabbitmq")
}
```

---

## üê≥ Docker Compose Atualizado

```yaml
# docker-compose.yml (atualizado para 2 microsservi√ßos)
version: '3.8'

services:
  # PostgreSQL para Warehouse
  warehouse-postgres:
    image: postgres:16-alpine
    container_name: warehouse-postgres
    environment:
      POSTGRES_DB: warehouse_db
      POSTGRES_USER: warehouse_user
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - warehouse-data:/var/lib/postgresql/data
    networks:
      - ecommerce-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U warehouse_user -d warehouse_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  # PostgreSQL para Storefront
  storefront-postgres:
    image: postgres:16-alpine
    container_name: storefront-postgres
    environment:
      POSTGRES_DB: storefront_db
      POSTGRES_USER: storefront_user
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    ports:
      - "5433:5432"  # Porta externa diferente!
    volumes:
      - storefront-data:/var/lib/postgresql/data
    networks:
      - ecommerce-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U storefront_user -d storefront_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  # RabbitMQ (compartilhado)
  rabbitmq:
    image: rabbitmq:3.12-management-alpine
    container_name: ecommerce-rabbitmq
    ports:
      - "5672:5672"    # AMQP
      - "15672:15672"  # Management UI
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}
    volumes:
      - rabbitmq-data:/var/lib/rabbitmq
    networks:
      - ecommerce-network
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Warehouse Microservice
  warehouse-service:
    build:
      context: ./warehouse
      dockerfile: Dockerfile
    container_name: warehouse-service
    ports:
      - "8080:8080"
    environment:
      SPRING_DATASOURCE_URL: jdbc:postgresql://warehouse-postgres:5432/warehouse_db
      SPRING_DATASOURCE_USERNAME: warehouse_user
      SPRING_DATASOURCE_PASSWORD: ${POSTGRES_PASSWORD}
      SPRING_RABBITMQ_HOST: rabbitmq
      SPRING_RABBITMQ_USERNAME: ${RABBITMQ_USER}
      SPRING_RABBITMQ_PASSWORD: ${RABBITMQ_PASSWORD}
      JWT_SECRET: ${JWT_SECRET}
    depends_on:
      warehouse-postgres:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    networks:
      - ecommerce-network
    restart: unless-stopped

  # Storefront Microservice
  storefront-service:
    build:
      context: ./storefront
      dockerfile: Dockerfile
    container_name: storefront-service
    ports:
      - "8081:8081"
    environment:
      SERVER_PORT: 8081
      SPRING_DATASOURCE_URL: jdbc:postgresql://storefront-postgres:5432/storefront_db
      SPRING_DATASOURCE_USERNAME: storefront_user
      SPRING_DATASOURCE_PASSWORD: ${POSTGRES_PASSWORD}
      SPRING_RABBITMQ_HOST: rabbitmq
      SPRING_RABBITMQ_USERNAME: ${RABBITMQ_USER}
      SPRING_RABBITMQ_PASSWORD: ${RABBITMQ_PASSWORD}
      JWT_SECRET: ${JWT_SECRET}
      WAREHOUSE_API_URL: http://warehouse-service:8080
    depends_on:
      storefront-postgres:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
      warehouse-service:
        condition: service_started
    networks:
      - ecommerce-network
    restart: unless-stopped

volumes:
  warehouse-data:
  storefront-data:
  rabbitmq-data:

networks:
  ecommerce-network:
    driver: bridge
```

---

## üìÅ Estrutura de Diret√≥rios

```
ecommerce-platform/
‚îú‚îÄ‚îÄ warehouse/                      # Microsservi√ßo Warehouse (EXISTENTE)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ build.gradle.kts
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ
‚îú‚îÄ‚îÄ storefront/                     # Microsservi√ßo Storefront (NOVO)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ java/br/com/dio/storefront/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Product.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ShoppingCart.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Order.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Customer.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ valueobject/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Money.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Address.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PaymentInfo.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repository/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ exception/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ port/in/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AddToCartUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CheckoutUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateOrderUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetProductsUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ port/out/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ WarehouseClient.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ service/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CartService.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ OrderService.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ProductService.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adapter/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ in/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ web/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controller/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mapper/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ messaging/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ StockUpdateEventConsumer.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ out/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ persistence/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ http/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ WarehouseHttpClient.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ messaging/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ OrderEventPublisher.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RabbitMQConfig.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SecurityConfig.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RestTemplateConfig.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OpenAPIConfig.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ security/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ JwtTokenProvider.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ JwtAuthenticationFilter.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StorefrontApplication.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ resources/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ application.yml
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ application-dev.yml
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ application-prod.yml
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ db/migration/
‚îÇ   ‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ V1__create_products_table.sql
‚îÇ   ‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ V2__create_customers_table.sql
‚îÇ   ‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ V3__create_shopping_carts_table.sql
‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ V4__create_orders_table.sql
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ java/br/com/dio/storefront/
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ build.gradle.kts
‚îÇ   ‚îú‚îÄ‚îÄ settings.gradle.kts
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ .env.example
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îÇ
‚îú‚îÄ‚îÄ docker-compose.yml              # Orquestra AMBOS os servi√ßos
‚îú‚îÄ‚îÄ .gitignore
‚îî‚îÄ‚îÄ README.md                       # Documenta√ß√£o do projeto completo
```

---

## üöÄ Roadmap de Implementa√ß√£o

### **Fase 1: Setup Inicial** (2-3 horas)
- [ ] Criar diret√≥rio `storefront/` na raiz
- [ ] Configurar `build.gradle.kts` com depend√™ncias
- [ ] Criar `application.yml` com configura√ß√µes
- [ ] Configurar `.env` com vari√°veis de ambiente
- [ ] Criar `StorefrontApplication.java`

### **Fase 2: Domain Layer** (4-6 horas)
- [ ] Implementar `Product` entity
- [ ] Implementar `ShoppingCart` aggregate
- [ ] Implementar `Order` aggregate
- [ ] Implementar `Customer` entity
- [ ] Criar Value Objects (Money, Address, PaymentInfo)
- [ ] Criar Domain Events (OrderCreated, CartCheckoutStarted)
- [ ] Criar Domain Exceptions

### **Fase 3: Application Layer** (4-6 horas)
- [ ] Criar Use Cases (Input Ports):
  - [ ] AddToCartUseCase
  - [ ] CheckoutUseCase
  - [ ] CreateOrderUseCase
  - [ ] GetProductsUseCase
  - [ ] GetOrdersUseCase
- [ ] Criar Output Ports:
  - [ ] WarehouseClient (interface)
  - [ ] EventPublisher (interface)
- [ ] Implementar Services

### **Fase 4: Infrastructure Layer** (6-8 horas)
- [ ] **Persistence:**
  - [ ] JPA Repositories
  - [ ] Flyway Migrations (4 arquivos SQL)
- [ ] **HTTP Client:**
  - [ ] Implementar WarehouseHttpClient com RestTemplate
  - [ ] Circuit Breaker (Resilience4j)
- [ ] **Messaging:**
  - [ ] RabbitMQ Configuration
  - [ ] StockUpdateEventConsumer
  - [ ] OrderEventPublisher
- [ ] **Security:**
  - [ ] JWT Configuration (reutilizar do Warehouse)
  - [ ] SecurityConfig

### **Fase 5: Adapter Layer - REST API** (6-8 horas)
- [ ] **Controllers:**
  - [ ] ProductController
  - [ ] CartController
  - [ ] OrderController
  - [ ] CustomerController
  - [ ] AuthenticationController
- [ ] **DTOs:** 15+ classes
- [ ] **Mappers:** MapStruct mappers
- [ ] **Exception Handlers:** GlobalExceptionHandler

### **Fase 6: Testing** (6-8 horas)
- [ ] Unit Tests (Domain, Application)
- [ ] Integration Tests (API, Database)
- [ ] RabbitMQ Tests (Testcontainers)
- [ ] Contract Tests (comunica√ß√£o com Warehouse)

### **Fase 7: Documentation** (2-3 horas)
- [ ] OpenAPI/Swagger annotations
- [ ] README.md do Storefront
- [ ] Diagramas de arquitetura
- [ ] Guia de API

### **Fase 8: Docker & DevOps** (2-3 horas)
- [ ] Dockerfile do Storefront
- [ ] Atualizar docker-compose.yml
- [ ] Scripts de inicializa√ß√£o
- [ ] Health checks

### **Fase 9: Integration End-to-End** (4-6 horas)
- [ ] Testar comunica√ß√£o HTTP Storefront ‚Üí Warehouse
- [ ] Testar eventos RabbitMQ em ambas dire√ß√µes
- [ ] Validar fluxo completo: Criar pedido ‚Üí Reservar estoque ‚Üí Processar venda
- [ ] Testar falhas e rollbacks

### **Fase 10: Refinamento** (2-4 horas)
- [ ] Code review
- [ ] Otimiza√ß√µes de performance
- [ ] Logging e monitoramento
- [ ] Documenta√ß√£o final

**TOTAL ESTIMADO:** 38-55 horas (~1-2 semanas)

---

## üîÑ Fluxo de Neg√≥cio Completo

### Cen√°rio: Cliente Compra 3 Cestas B√°sicas

```
1. CLIENTE (Frontend)
   ‚Üì GET /api/v1/products
   
2. STOREFRONT
   ‚Üì Consulta produtos no banco local
   ‚Üì HTTP GET ‚Üí http://warehouse:8080/api/v1/stock
   
3. WAREHOUSE
   ‚Üì Retorna estoque dispon√≠vel: 100 cestas
   ‚Üì Response: { "availableBaskets": 100, "totalInventoryValue": 6250.00 }
   
4. STOREFRONT
   ‚Üì Atualiza cache de estoque
   ‚Üì Retorna produtos para o cliente
   
5. CLIENTE
   ‚Üì POST /api/v1/cart/items { "productId": "...", "quantity": 3 }
   
6. STOREFRONT
   ‚Üì Valida disponibilidade
   ‚Üì Adiciona ao carrinho (n√£o reserva ainda)
   ‚Üì Response: Carrinho atualizado
   
7. CLIENTE
   ‚Üì POST /api/v1/cart/checkout
   
8. STOREFRONT
   ‚Üì Cria pedido (status: PENDING)
   ‚Üì HTTP POST ‚Üí http://warehouse:8080/api/v1/baskets/reserve { "quantity": 3 }
   
9. WAREHOUSE
   ‚Üì Reserva 3 cestas (status: RESERVED)
   ‚Üì Response: { "success": true, "reservedBaskets": [...] }
   
10. STOREFRONT
    ‚Üì Confirma pedido (status: CONFIRMED)
    ‚Üì RabbitMQ PUBLISH ‚Üí OrderCreatedEvent
    
11. WAREHOUSE (Consumer)
    ‚Üì Consome OrderCreatedEvent
    ‚Üì Marca cestas como SOLD
    ‚Üì RabbitMQ PUBLISH ‚Üí BasketsSoldEvent
    
12. STOREFRONT (Consumer)
    ‚Üì Consome BasketsSoldEvent
    ‚Üì Atualiza cache de estoque (-3)
    ‚Üì Atualiza pedido (status: PROCESSING)
    
13. RESPONSE ao Cliente
    ‚Üì { "orderId": "...", "status": "CONFIRMED", "total": 18.75 }
```

---

## üéØ Crit√©rios de Sucesso

### Funcional
- [ ] Storefront pode consultar estoque do Warehouse (HTTP s√≠ncrono)
- [ ] Storefront consome eventos de estoque (RabbitMQ ass√≠ncrono)
- [ ] Warehouse consome eventos de pedidos (RabbitMQ ass√≠ncrono)
- [ ] Carrinho de compras funciona corretamente
- [ ] Checkout cria pedidos e reserva estoque
- [ ] Pedidos t√™m lifecycle completo (PENDING ‚Üí CONFIRMED ‚Üí PROCESSING ‚Üí DELIVERED)

### T√©cnico
- [ ] Ambos microsservi√ßos seguem Hexagonal Architecture
- [ ] Ambos usam Domain-Driven Design
- [ ] Comunica√ß√£o s√≠ncrona com Circuit Breaker
- [ ] Comunica√ß√£o ass√≠ncrona com retry policy
- [ ] Cada microsservi√ßo tem seu pr√≥prio banco de dados
- [ ] RabbitMQ compartilhado entre servi√ßos
- [ ] Autentica√ß√£o JWT funciona em ambos
- [ ] Cobertura de testes > 80%

### DevOps
- [ ] Docker Compose inicia ambos servi√ßos + infra
- [ ] Health checks funcionando
- [ ] Logs estruturados
- [ ] M√©tricas do Actuator
- [ ] Swagger UI documentando ambas APIs

---

## üìö Refer√™ncias

- [Spring Cloud OpenFeign](https://spring.io/projects/spring-cloud-openfeign)
- [Resilience4j Circuit Breaker](https://resilience4j.readme.io/docs/circuitbreaker)
- [RabbitMQ Best Practices](https://www.rabbitmq.com/tutorials/tutorial-one-java.html)
- [Hexagonal Architecture](https://alistair.cockburn.us/hexagonal-architecture/)
- [Domain-Driven Design](https://martinfowler.com/bliki/DomainDrivenDesign.html)

---


---

**Status Final**: ‚úÖ Storefront/frontend 100% conclu√≠do e integrado. Todas as etapas do plano foram realizadas com sucesso.

**√öltima Atualiza√ß√£o**: 15 de Outubro de 2025
