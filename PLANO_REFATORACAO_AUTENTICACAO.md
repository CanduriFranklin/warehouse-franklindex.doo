# üèóÔ∏è PLANO CIR√öRGICO: REFATORA√á√ÉO DE AUTENTICA√á√ÉO PARA BANCO DE DADOS

## üìã OBJETIVO
Migrar sistema de autentica√ß√£o de **InMemory** para **Banco de Dados Relacional**, unificando todos os usu√°rios (admin, manager, sales, clientes) em um √∫nico sistema escal√°vel, seguro e sustent√°vel.

---

## üìä ARQUITETURA ATUAL vs FUTURA

### ANTES (InMemory)
```
Autentica√ß√£o:
  ‚îî‚îÄ InMemoryUserDetailsService
     ‚îú‚îÄ admin (memory)
     ‚îú‚îÄ manager (memory)
     ‚îî‚îÄ sales (memory)

Clientes:
  ‚îî‚îÄ Tabela: clientes (sem autentica√ß√£o)
```

### DEPOIS (Banco de Dados)
```
Autentica√ß√£o Unificada:
  ‚îî‚îÄ DatabaseUserDetailsService
     ‚îú‚îÄ Tabela: usuarios
     ‚îÇ  ‚îú‚îÄ admin (BD + roles)
     ‚îÇ  ‚îú‚îÄ manager (BD + roles)
     ‚îÇ  ‚îú‚îÄ sales (BD + roles)
     ‚îÇ  ‚îî‚îÄ clientes (BD + roles)
     ‚îî‚îÄ UserRole (tabela de relacionamento)

Clientes:
  ‚îî‚îÄ Tabela: clientes (estendida com autentica√ß√£o)
```

---

## üîß FASES DE IMPLEMENTA√á√ÉO

### FASE 1: Design do Banco de Dados
**Dura√ß√£o: 30 minutos**
**Arquivos:**
- V4__Create_usuario_e_roles.sql (nova migra√ß√£o Flyway)
- V5__Migrate_dev_users.sql (migra√ß√£o de dados)

**Tarefas:**
```
1.1. Criar tabela `usuarios`
     ‚îî‚îÄ Substitui InMemory completamente
     
1.2. Criar tabela `usuario_roles` (Many-to-Many)
     ‚îî‚îÄ Relacionamento: usuarios ‚Üê‚Üí roles
     
1.3. Criar tabela `roles`
     ‚îî‚îÄ ROLE_ADMIN, ROLE_WAREHOUSE_MANAGER, ROLE_SALES
     
1.4. Adicionar colunas de auditoria
     ‚îî‚îÄ criado_em, atualizado_em, ativo, ultimo_acesso
     
1.5. Adicionar √≠ndices para performance
     ‚îî‚îÄ username UNIQUE, email UNIQUE, ativo
```

---

### FASE 2: Implementa√ß√£o Backend
**Dura√ß√£o: 2-3 horas**

#### 2.1 Criar Entidades JPA
**Arquivos a criar:**
```
src/main/java/br/com/dio/warehouse/
  ‚îî‚îÄ domain/
     ‚îî‚îÄ model/
        ‚îú‚îÄ Usuario.java (Entity)
        ‚îú‚îÄ Role.java (Entity)
        ‚îî‚îÄ UsuarioRole.java (Entity - Composite)
```

**Estrutura Usuario.java:**
```java
@Entity
@Table(name = "usuarios")
public class Usuario {
  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;
  
  @Column(nullable = false, unique = true, length = 50)
  private String username;
  
  @Column(nullable = false, unique = true, length = 100)
  private String email;
  
  @Column(nullable = false, length = 255)
  private String senhaHash; // BCrypt
  
  @ManyToMany(fetch = FetchType.EAGER)
  @JoinTable(
    name = "usuario_roles",
    joinColumns = @JoinColumn(name = "usuario_id"),
    inverseJoinColumns = @JoinColumn(name = "role_id")
  )
  private Set<Role> roles = new HashSet<>();
  
  @Column(nullable = false)
  private Boolean ativo = true;
  
  @Column
  private LocalDateTime ultimoAcesso;
  
  @Column(nullable = false, updatable = false)
  private LocalDateTime criadoEm = LocalDateTime.now();
  
  @Column(nullable = false)
  private LocalDateTime atualizadoEm = LocalDateTime.now();
  
  // factory methods, getters, setters...
}
```

**Estrutura Role.java:**
```java
@Entity
@Table(name = "roles")
public class Role {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  
  @Column(nullable = false, unique = true, length = 50)
  @Enumerated(EnumType.STRING)
  private RoleEnum nome; // ADMIN, WAREHOUSE_MANAGER, SALES
  
  @Column(length = 255)
  private String descricao;
  
  // getters, setters...
}
```

#### 2.2 Criar Reposit√≥rios
**Arquivos a criar:**
```
src/main/java/br/com/dio/warehouse/
  ‚îî‚îÄ infrastructure/
     ‚îî‚îÄ persistence/
        ‚îú‚îÄ UsuarioRepository.java
        ‚îî‚îÄ RoleRepository.java
```

**UsuarioRepository.java:**
```java
@Repository
public interface UsuarioRepository extends JpaRepository<Usuario, UUID> {
  Optional<Usuario> findByUsername(String username);
  Optional<Usuario> findByEmail(String email);
  boolean existsByUsername(String username);
  boolean existsByEmail(String email);
  List<Usuario> findAllByAtivoTrue();
}
```

#### 2.3 Implementar DatabaseUserDetailsService
**Arquivo a criar:**
```
src/main/java/br/com/dio/warehouse/
  ‚îî‚îÄ infrastructure/
     ‚îî‚îÄ security/
        ‚îî‚îÄ DatabaseUserDetailsService.java
```

**Substitui:** InMemoryUserDetailsService.java

**Estrutura:**
```java
@Service
@Slf4j
public class DatabaseUserDetailsService implements UserDetailsService {
  
  private final UsuarioRepository usuarioRepository;
  
  @Override
  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    Usuario usuario = usuarioRepository.findByUsername(username)
      .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
    
    if (!usuario.getAtivo()) {
      throw new UserDisabledException("User account is disabled");
    }
    
    Collection<GrantedAuthority> authorities = usuario.getRoles()
      .stream()
      .map(role -> new SimpleGrantedAuthority("ROLE_" + role.getNome().name()))
      .collect(Collectors.toSet());
    
    return new org.springframework.security.core.userdetails.User(
      usuario.getUsername(),
      usuario.getSenhaHash(),
      authorities
    );
  }
}
```

#### 2.4 Criar DTO para Registro
**Arquivo a criar:**
```
src/main/java/br/com/dio/warehouse/
  ‚îî‚îÄ adapter/
     ‚îî‚îÄ in/
        ‚îî‚îÄ web/
           ‚îî‚îÄ dto/
              ‚îî‚îÄ auth/
                 ‚îî‚îÄ RegisterRequest.java
```

**Estrutura:**
```java
public record RegisterRequest(
  @NotBlank(message = "Username is required")
  @Size(min = 3, max = 50)
  String username,
  
  @NotBlank(message = "Email is required")
  @Email
  String email,
  
  @NotBlank(message = "Password is required")
  @Size(min = 8, max = 100)
  String password,
  
  @NotBlank(message = "Confirm password is required")
  String passwordConfirm,
  
  String nome,
  String cpf,
  String telefone
) {}
```

#### 2.5 Criar Service de Registro
**Arquivo a criar:**
```
src/main/java/br/com/dio/warehouse/
  ‚îî‚îÄ application/
     ‚îî‚îÄ service/
        ‚îî‚îÄ UsuarioRegistrationService.java
```

**M√©todos:**
```java
@Service
@Slf4j
public class UsuarioRegistrationService {
  
  private final UsuarioRepository usuarioRepository;
  private final RoleRepository roleRepository;
  private final PasswordEncoder passwordEncoder;
  
  public Usuario registrarNovoUsuario(RegisterRequest request) {
    // Validar campos
    if (!request.password().equals(request.passwordConfirm())) {
      throw new PasswordMismatchException("Passwords do not match");
    }
    
    // Verificar se username existe
    if (usuarioRepository.existsByUsername(request.username())) {
      throw new UsernameAlreadyExistsException("Username already taken");
    }
    
    // Verificar se email existe
    if (usuarioRepository.existsByEmail(request.email())) {
      throw new EmailAlreadyExistsException("Email already registered");
    }
    
    // Criar usuario
    Usuario usuario = Usuario.builder()
      .username(request.username())
      .email(request.email())
      .senhaHash(passwordEncoder.encode(request.password()))
      .ativo(true)
      .build();
    
    // Adicionar role padr√£o (SALES ou CUSTOMER)
    Role rolePadrao = roleRepository.findByNome(RoleEnum.SALES)
      .orElseThrow(() -> new RoleNotFoundException("Default role not found"));
    usuario.getRoles().add(rolePadrao);
    
    return usuarioRepository.save(usuario);
  }
}
```

#### 2.6 Adicionar Endpoint de Registro
**Modificar:** AuthenticationController.java

**Novo m√©todo:**
```java
@PostMapping("/register")
public ResponseEntity<JwtAuthenticationResponse> register(
    @Valid @RequestBody RegisterRequest registerRequest
) {
  try {
    // Registrar novo usuario
    Usuario novoUsuario = usuarioRegistrationService.registrarNovoUsuario(registerRequest);
    
    // Fazer login autom√°tico
    Authentication authentication = authenticationManager.authenticate(
      new UsernamePasswordAuthenticationToken(
        novoUsuario.getUsername(),
        registerRequest.password()
      )
    );
    
    SecurityContextHolder.getContext().setAuthentication(authentication);
    
    // Gerar token JWT
    String token = tokenProvider.generateToken(authentication);
    String roles = authentication.getAuthorities().stream()
      .map(GrantedAuthority::getAuthority)
      .collect(Collectors.joining(","));
    
    return ResponseEntity.ok(JwtAuthenticationResponse.of(
      token,
      Instant.now().plusMillis(tokenProvider.getExpirationMs()),
      novoUsuario.getUsername(),
      roles
    ));
    
  } catch (UsernameAlreadyExistsException | EmailAlreadyExistsException e) {
    return ResponseEntity.status(409).build(); // Conflict
  } catch (Exception e) {
    log.error("Registration failed", e);
    return ResponseEntity.status(400).build(); // Bad Request
  }
}
```

---

### FASE 3: Criar Migra√ß√µes Flyway
**Dura√ß√£o: 1 hora**

#### 3.1 V4__Create_usuario_e_roles.sql
```sql
-- Tabela de Roles (Pap√©is/Fun√ß√µes)
CREATE TABLE roles (
  id BIGSERIAL PRIMARY KEY,
  nome VARCHAR(50) NOT NULL UNIQUE,
  descricao VARCHAR(255),
  criado_em TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  atualizado_em TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Tabela de Usu√°rios (substitui InMemory)
CREATE TABLE usuarios (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  username VARCHAR(50) NOT NULL UNIQUE,
  email VARCHAR(100) NOT NULL UNIQUE,
  senha_hash VARCHAR(255) NOT NULL,
  ativo BOOLEAN NOT NULL DEFAULT true,
  ultimo_acesso TIMESTAMP,
  criado_em TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  atualizado_em TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Tabela de Relacionamento (Many-to-Many)
CREATE TABLE usuario_roles (
  usuario_id UUID NOT NULL,
  role_id BIGINT NOT NULL,
  PRIMARY KEY (usuario_id, role_id),
  FOREIGN KEY (usuario_id) REFERENCES usuarios(id) ON DELETE CASCADE,
  FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
);

-- √çndices para performance
CREATE INDEX idx_usuarios_username ON usuarios(username);
CREATE INDEX idx_usuarios_email ON usuarios(email);
CREATE INDEX idx_usuarios_ativo ON usuarios(ativo);
CREATE INDEX idx_usuario_roles_usuario ON usuario_roles(usuario_id);
CREATE INDEX idx_usuario_roles_role ON usuario_roles(role_id);

-- Fun√ß√£o para atualizar atualizado_em automaticamente
CREATE OR REPLACE FUNCTION update_atualizado_em()
RETURNS TRIGGER AS $$
BEGIN
  NEW.atualizado_em = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para usuarios
CREATE TRIGGER trg_usuarios_atualizado_em
BEFORE UPDATE ON usuarios
FOR EACH ROW
EXECUTE FUNCTION update_atualizado_em();

-- Trigger para roles
CREATE TRIGGER trg_roles_atualizado_em
BEFORE UPDATE ON roles
FOR EACH ROW
EXECUTE FUNCTION update_atualizado_em();
```

#### 3.2 V5__Seed_default_roles.sql
```sql
-- Inserir roles padr√£o
INSERT INTO roles (nome, descricao) VALUES
  ('ADMIN', 'Administrador com acesso total ao sistema'),
  ('WAREHOUSE_MANAGER', 'Gerenciador de warehouse'),
  ('SALES', 'Vendedor/Cliente padr√£o'),
  ('CUSTOMER', 'Cliente da loja')
ON CONFLICT (nome) DO NOTHING;
```

#### 3.3 V6__Migrate_dev_users.sql
```sql
-- Migrar usu√°rios de desenvolvimento (com senhas hasheadas)
-- NOTA: Senhas abaixo s√£o BCrypt hashed (10 rounds)
-- Admin2025Secure = $2a$10$...
-- Manager2025Secure = $2a$10$...
-- Sales2025Secure = $2a$10$...

INSERT INTO usuarios (username, email, senha_hash, ativo) VALUES
  ('admin', 'admin@warehouse.local', '$2a$10$YourHashedPasswordHere', true),
  ('manager', 'manager@warehouse.local', '$2a$10$YourHashedPasswordHere', true),
  ('sales', 'sales@warehouse.local', '$2a$10$YourHashedPasswordHere', true)
ON CONFLICT (username) DO NOTHING;

-- Relacionar usu√°rios com roles
INSERT INTO usuario_roles (usuario_id, role_id)
SELECT u.id, r.id FROM usuarios u, roles r
WHERE u.username = 'admin' AND r.nome = 'ADMIN'
ON CONFLICT DO NOTHING;

INSERT INTO usuario_roles (usuario_id, role_id)
SELECT u.id, r.id FROM usuarios u, roles r
WHERE u.username = 'manager' AND r.nome = 'WAREHOUSE_MANAGER'
ON CONFLICT DO NOTHING;

INSERT INTO usuario_roles (usuario_id, role_id)
SELECT u.id, r.id FROM usuarios u, roles r
WHERE u.username = 'sales' AND r.nome = 'SALES'
ON CONFLICT DO NOTHING;
```

---

### FASE 4: Atualizar Configura√ß√£o Spring Security
**Dura√ß√£o: 30 minutos**

#### 4.1 Remover InMemoryUserDetailsService
**A√ß√£o:** Deletar arquivo ou comentar `@Service`

#### 4.2 Ativar DatabaseUserDetailsService
**A√ß√£o:** Adicionar `@Service` e garantir que seja √∫nico UserDetailsService

#### 4.3 Atualizar SecurityConfig
```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {
  
  private final DatabaseUserDetailsService userDetailsService;
  
  @Bean
  public UserDetailsService userDetailsService() {
    return userDetailsService; // Database-backed
  }
  
  @Bean
  public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
    return config.getAuthenticationManager();
  }
  
  // ... resto da config
}
```

---

### FASE 5: Atualizar Frontend
**Dura√ß√£o: 1 hora**

#### 5.1 AuthContext.tsx
```typescript
const register = async (username: string, email: string, password: string) => {
  try {
    const response = await axios.post('http://localhost:8080/api/v1/auth/register', {
      username,
      email,
      password,
      passwordConfirm: password,
      nome: username,
      cpf: '',
      telefone: ''
    });

    const { token, username: userName, roles } = response.data;
    
    setToken(token);
    setUser({ username: userName, roles });
    
    localStorage.setItem('auth_token', token);
    localStorage.setItem('user_data', JSON.stringify({ username: userName, roles }));
  } catch (error) {
    console.error('Erro no registro:', error);
    throw new Error('Falha ao criar conta');
  }
};
```

#### 5.2 AuthPage.tsx
```typescript
const handleRegister = async (e: React.FormEvent) => {
  e.preventDefault();
  setError('');
  
  if (registerData.password !== registerData.confirmPassword) {
    setError('As senhas n√£o coincidem');
    return;
  }
  
  setLoading(true);
  
  try {
    await register(
      registerData.username,
      registerData.email,
      registerData.password
    );
    navigate('/dashboard');
  } catch (err) {
    setError('Erro ao criar conta. Tente novamente.');
  } finally {
    setLoading(false);
  }
};
```

---

### FASE 6: Testes e Valida√ß√£o
**Dura√ß√£o: 1 hora**

#### 6.1 Testes Unit√°rios Backend
```
src/test/java/br/com/dio/warehouse/
  ‚îî‚îÄ infrastructure/
     ‚îî‚îÄ security/
        ‚îî‚îÄ DatabaseUserDetailsServiceTest.java
        ‚îî‚îÄ UsuarioRegistrationServiceTest.java
```

#### 6.2 Testes de Integra√ß√£o
```
src/test/java/br/com/dio/warehouse/
  ‚îî‚îÄ adapter/
     ‚îî‚îÄ in/
        ‚îî‚îÄ web/
           ‚îî‚îÄ controller/
              ‚îî‚îÄ AuthenticationControllerIT.java
```

#### 6.3 Testes Manuais
```
1. ‚úÖ Login com admin/Admin2025Secure
2. ‚úÖ Login com manager/Manager2025Secure
3. ‚úÖ Criar novo usu√°rio via /api/v1/auth/register
4. ‚úÖ Login com novo usu√°rio
5. ‚úÖ Verificar token JWT
6. ‚úÖ Logout
7. ‚úÖ Tentar login com credenciais inv√°lidas
8. ‚úÖ Frontend: Registrar novo cliente
9. ‚úÖ Frontend: Login com novo cliente
```

---

## üìã CHECKLIST DE EXECU√á√ÉO

### ANTES DE COME√áAR
- [ ] Fazer backup do banco de dados
- [ ] Criar branch git: `git checkout -b refactor/auth-to-database`
- [ ] Documentar estado atual dos testes

### FASE 1: Banco de Dados
- [ ] Criar V4__Create_usuario_e_roles.sql
- [ ] Criar V5__Seed_default_roles.sql
- [ ] Criar V6__Migrate_dev_users.sql
- [ ] Testar migra√ß√µes localmente

### FASE 2: Backend - Entidades
- [ ] Criar Usuario.java
- [ ] Criar Role.java
- [ ] Criar UsuarioRole.java
- [ ] Criar UsuarioRepository.java
- [ ] Criar RoleRepository.java

### FASE 3: Backend - Services
- [ ] Criar DatabaseUserDetailsService.java
- [ ] Criar UsuarioRegistrationService.java
- [ ] Adicionar endpoint /api/v1/auth/register
- [ ] Adicionar DTOs (RegisterRequest, etc)

### FASE 4: Configura√ß√£o
- [ ] Atualizar SecurityConfig.java
- [ ] Remover/desabilitar InMemoryUserDetailsService
- [ ] Atualizar application.yml (remover dev.users.*)
- [ ] Compilar sem erros

### FASE 5: Frontend
- [ ] Atualizar AuthContext.tsx
- [ ] Atualizar AuthPage.tsx
- [ ] Testar formul√°rio de registro
- [ ] Testar fluxo de login

### FASE 6: Testes
- [ ] Testes unit√°rios passando
- [ ] Testes de integra√ß√£o passando
- [ ] Testes manuais todos OK
- [ ] Sem regressions em funcionalidades existentes

### FINALIZA√á√ÉO
- [ ] Commit com mensagem descritiva
- [ ] Push para branch
- [ ] Criar Pull Request
- [ ] Code review
- [ ] Merge para main
- [ ] Deploy

---

## üöÄ ORDEM DE EXECU√á√ÉO RECOMENDADA

```
1Ô∏è‚É£  FASE 1: Banco de Dados (30 min)
    ‚îî‚îÄ Criar migra√ß√µes Flyway
    ‚îî‚îÄ Testar localmente

2Ô∏è‚É£  FASE 2.1-2.2: Entidades + Repos (30 min)
    ‚îî‚îÄ Criar entidades JPA
    ‚îî‚îÄ Criar reposit√≥rios
    ‚îî‚îÄ Compilar sem erros

3Ô∏è‚É£  FASE 2.3-2.5: Services (1 hora)
    ‚îî‚îÄ DatabaseUserDetailsService
    ‚îî‚îÄ UsuarioRegistrationService
    ‚îî‚îÄ Novo endpoint /register

4Ô∏è‚É£  FASE 3: Testes Backend (30 min)
    ‚îî‚îÄ Testes unit√°rios
    ‚îî‚îÄ Testes de integra√ß√£o

5Ô∏è‚É£  FASE 4: Configura√ß√£o (30 min)
    ‚îî‚îÄ Atualizar SecurityConfig
    ‚îî‚îÄ Limpar configura√ß√µes antigas

6Ô∏è‚É£  FASE 5: Frontend (1 hora)
    ‚îî‚îÄ Atualizar contexto auth
    ‚îî‚îÄ Atualizar formul√°rios

7Ô∏è‚É£  FASE 6: Testes Finais (30 min)
    ‚îî‚îÄ Testes manuais
    ‚îî‚îÄ Valida√ß√£o completa
```

**TEMPO TOTAL: ~5-6 horas**

---

## ‚ö†Ô∏è PONTOS DE ATEN√á√ÉO

1. **Senhas hasheadas em BD:**
   - Usar BCrypt sempre
   - Nunca armazenar em plain text
   - Validar durante teste

2. **Migra√ß√£o de dados dev users:**
   - Testar senha hasheada manualmente
   - Garantir que login ainda funciona
   - Documentar novo processo

3. **Compatibilidade com JWT:**
   - Verificar se roles ainda s√£o extra√≠das corretamente
   - Testar token com novo UserDetailsService
   - Validar permiss√µes

4. **Performance:**
   - √çndices em username e email
   - Fetch EAGER em roles (pequeno set)
   - Considerar cache se muitos logins

5. **Seguran√ßa:**
   - Validar senha forte (8+ chars)
   - Rate limiting em /register
   - Log de tentativas de login falhas

---

## üìö REFER√äNCIAS DE C√ìDIGO

- Spring Security UserDetailsService: https://docs.spring.io/spring-security/reference/servlet/authentication/userdetails/index.html
- BCrypt Password Encoder: https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/password-encoders.html
- JPA Many-to-Many: https://hibernate.org/orm/documentation/
- Flyway Migrations: https://flywaydb.org/

---

## ‚úÖ CRIT√âRIO DE SUCESSO

Implementa√ß√£o ser√° considerada **SUCESSO** quando:

1. ‚úÖ Todos os 3 usu√°rios de dev fazem login com sucesso
2. ‚úÖ Novo usu√°rio pode se registrar via `/api/v1/auth/register`
3. ‚úÖ Novo usu√°rio recebe token JWT v√°lido
4. ‚úÖ Novo usu√°rio pode fazer login ap√≥s registro
5. ‚úÖ Roles e permiss√µes funcionam corretamente
6. ‚úÖ Frontend consegue registrar e fazer login
7. ‚úÖ Todos os testes passam
8. ‚úÖ Sem regressions em funcionalidades existentes
9. ‚úÖ C√≥digo segue padr√µes da base (estrutura, naming, conventions)
10. ‚úÖ Documenta√ß√£o atualizada

